<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Knee Flexion Calculator</title>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@^2.0/dist/tailwind.min.css" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
  <style>
    /* Ensure the angleCanvas is responsive */
    #angleCanvas {
      width: 100% !important;
      height: auto !important;
    }

    /* Define a fixed height for the progressChart container to ensure visibility */
    #progressChartContainer {
      position: relative;
      width: 100%;
      height: 400px; /* Default height */
    }

    /* Adjust height for smaller screens */
    @media (max-width: 640px) {
      #progressChartContainer {
        height: 300px;
      }
    }

    /* Modal backdrop transition */
    .modal-backdrop {
      transition: opacity 0.25s ease;
    }

    /* Hide video stream initially */
    #videoStream {
      display: none;
    }

    /* Styling for camera flip button */
    .camera-flip-button {
      background-color: rgba(0, 0, 0, 0.5);
      border: none;
      color: #fff;
      font-size: 1.5rem;
      cursor: pointer;
      padding: 0.5rem;
      border-radius: 50%;
      position: absolute;
      top: 1rem;
      right: 1rem;
      z-index: 10;
    }

    .camera-flip-button:focus {
      outline: none;
    }

    /* Tooltip Styling */
    .tooltip {
      position: relative;
      display: inline-block;
      cursor: pointer;
    }

    .tooltip .tooltiptext {
      visibility: hidden;
      width: 220px;
      background-color: #4a90e2;
      color: #fff;
      text-align: center;
      border-radius: 6px;
      padding: 10px;
      position: absolute;
      z-index: 1;
      bottom: 125%; /* Position above the icon */
      left: 50%;
      margin-left: -110px; /* Center the tooltip */
      opacity: 0;
      transition: opacity 0.3s;
    }

    .tooltip:hover .tooltiptext {
      visibility: visible;
      opacity: 1;
    }

    /* Responsive Adjustments */
    @media (max-width: 640px) {
      .tooltip .tooltiptext {
        width: 180px;
        margin-left: -90px;
      }
    }
  </style>
</head>
<body class="bg-gray-100 font-sans">
  <div class="container mx-auto p-4 sm:p-6 lg:p-8">
    <!-- Header with Info Button -->
    <div class="flex justify-between items-center mb-8 sm:mb-10">
      <h1 class="text-3xl sm:text-4xl font-bold text-blue-700">Knee Flexion Calculator</h1>
      <!-- Info Button -->
      <button onclick="openInfoModal()" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded flex items-center">
        <i class="fas fa-info-circle mr-2"></i> Info
      </button>
    </div>

    <div class="grid grid-cols-1 md:grid-cols-2 gap-6 sm:gap-8">
      <!-- Input Section -->
      <div class="bg-white p-6 sm:p-8 rounded-lg shadow-lg">
        <div class="flex flex-col gap-3 sm:gap-4 mb-5 sm:mb-6">
          <input type="text" id="userName" placeholder="Enter patient name" class="p-3 sm:p-4 border border-gray-300 rounded text-base sm:text-lg" aria-label="Patient Name">
          <input type="date" id="dateInput" class="p-3 sm:p-4 border border-gray-300 rounded text-base sm:text-lg" aria-label="Date">
        </div>
        <div class="mb-5 sm:mb-6">
          <!-- The file input is now inside the modal, so we can remove it here or keep it hidden for fallback -->
          <input type="file" id="imageInput" accept="image/*" class="hidden" aria-label="Upload Image">
          <p class="text-gray-500 text-xs sm:text-sm mt-1 sm:mt-2">
            Please upload an image of the patient with a clear view of their knee flexion.
          </p>
          <p class="text-gray-500 text-xs sm:text-sm mt-1 sm:mt-2">
            Ensure the patient is positioned side-on (sagittal view) to the camera for accurate knee flexion measurement.
          </p>
        </div>
        <div class="flex flex-col sm:flex-row justify-between gap-3 sm:gap-4">
          <button onclick="openUploadModal()" id="calculateButton" class="flex-1 bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 sm:py-3 px-4 sm:px-6 rounded flex items-center justify-center">
            Upload and Adjust Points <i class="fas fa-upload ml-2"></i>
          </button>
          <button onclick="openResetModal()" class="flex-1 bg-red-500 hover:bg-red-700 text-white font-bold py-2 sm:py-3 px-4 sm:px-6 rounded flex items-center justify-center">
            Reset Data <i class="fas fa-trash ml-2"></i>
          </button>
        </div>
      </div>

      <!-- Image and Angle Adjustment Section -->
      <div id="imageContainer" class="bg-white p-6 sm:p-8 rounded-lg shadow-lg hidden">
        <h2 class="text-2xl sm:text-3xl font-bold text-center text-blue-700 mb-4 sm:mb-6">Adjust Points to Calculate Knee Flexion Angle</h2>
        <p class="text-gray-500 text-xs sm:text-sm text-center mb-3 sm:mb-4">
          Drag the red points to adjust their positions if needed. Ensure accurate placement for the best results.
        </p>
        <div class="flex justify-center relative">
          <canvas id="angleCanvas" class="w-full max-w-full"></canvas>
        </div>
        <div class="flex justify-center mt-3 sm:mt-4" id="angleMessageContainer"></div>
        <div class="flex justify-center mt-3 sm:mt-4">
          <button id="confirmButton" class="bg-green-500 hover:bg-green-700 text-white font-bold py-2 px-4 sm:py-3 sm:px-6 rounded">Confirm and Save Angle</button>
        </div>
      </div>
    </div>

    <!-- Status Message -->
    <div id="statusMessage" class="text-center text-base sm:text-lg text-blue-700 mt-3 sm:mt-4 hidden"></div>

    <!-- Progress Chart Section -->
    <div class="bg-white p-6 sm:p-8 rounded-lg shadow-lg mt-6 sm:mt-10">
      <div class="flex flex-col sm:flex-row justify-between items-center mb-4 sm:mb-6">
        <div class="w-full sm:w-auto mb-4 sm:mb-0">
          <label for="patientSelect" class="block text-md sm:text-lg font-medium text-gray-700 mb-1 sm:mb-0">Select Patient:</label>
          <select id="patientSelect" class="w-full sm:w-auto p-2 border border-gray-300 rounded text-base sm:text-lg" onchange="updateProgressChart()"></select>
        </div>
        <button onclick="openDeletePatientModal()" class="w-full sm:w-auto bg-red-500 hover:bg-red-700 text-white font-bold py-2 px-4 sm:py-3 sm:px-6 rounded">Delete Selected Patient Data</button>
      </div>
      <div id="progressChartContainer">
        <canvas id="progressChart" class="w-full h-full"></canvas>
      </div>
    </div>
  </div>

  <!-- Information Modal -->
  <div id="infoModal" class="fixed inset-0 flex items-center justify-center bg-gray-800 bg-opacity-50 hidden">
    <div class="bg-white rounded-lg shadow-lg w-11/12 sm:w-2/3 lg:w-1/2">
      <div class="px-6 py-4">
        <h3 class="text-lg sm:text-xl font-semibold text-gray-800">About Knee Flexion Calculator</h3>
        <p class="mt-2 text-gray-600">
          The <strong>Knee Flexion Calculator</strong> is a tool designed to assist healthcare professionals, physiotherapists, and athletes in accurately measuring knee flexion angles. By analyzing images of the knee, this application provides precise measurements essential for diagnosing, monitoring, and rehabilitating knee conditions.
        </p>
      </div>
      <div class="px-6 py-2">
        <h4 class="text-md sm:text-lg font-semibold text-gray-800">Key Applications:</h4>
        <ul class="list-disc list-inside text-gray-600 mt-2">
          <li><strong>ACL Injury Assessment:</strong> Evaluate the severity of Anterior Cruciate Ligament injuries and monitor recovery progress.</li>
          <li><strong>Rehabilitation Tracking:</strong> Monitor patients' progress during physical therapy to ensure effective recovery.</li>
          <li><strong>Sports Performance:</strong> Analyze athletes' knee movements to enhance performance and prevent injuries.</li>
          <li><strong>Post-Surgery Evaluation:</strong> Assess knee function after surgical interventions to guide further treatment.</li>
          <li><strong>Orthopedic Research:</strong> Facilitate studies on knee biomechanics and the effectiveness of various treatments.</li>
        </ul>
      </div>
      <div class="flex justify-end px-6 py-4">
        <button onclick="closeInfoModal()" class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-semibold py-2 px-4 rounded">Close</button>
      </div>
    </div>
  </div>

  <!-- Upload Modal -->
  <div id="uploadModal" class="fixed inset-0 flex items-center justify-center bg-gray-800 bg-opacity-50 hidden">
    <div class="bg-white rounded-lg shadow-lg w-11/12 sm:w-2/3 lg:w-1/2">
      <div class="px-6 py-4">
        <h3 class="text-lg sm:text-xl font-semibold text-gray-800">Upload Image</h3>
        <p class="mt-2 text-gray-600">Choose to take a photo using your camera or upload an existing image.</p>
      </div>
      <div class="flex flex-col sm:flex-row justify-around items-center px-6 py-4 gap-4">
        <!-- Take Photo Button -->
        <button onclick="openCamera()" class="flex-1 flex items-center justify-center bg-green-500 hover:bg-green-700 text-white font-semibold py-2 px-4 rounded">
          <i class="fas fa-camera mr-2"></i> Take Photo
        </button>
        <!-- Upload Image Button -->
        <button onclick="triggerImageUpload()" class="flex-1 flex items-center justify-center bg-blue-500 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded">
          <i class="fas fa-upload mr-2"></i> Upload Image
        </button>
      </div>
      <!-- Video Stream Section with Flip Icon Overlay -->
      <div id="cameraSection" class="px-6 py-4 hidden relative">
        <button onclick="flipCamera()" class="camera-flip-button" aria-label="Flip Camera">
          <i class="fas fa-sync-alt"></i>
        </button>
        <video id="videoStream" class="w-full rounded-lg"></video>
        <div class="flex justify-center mt-4">
          <button onclick="capturePhoto()" class="bg-purple-500 hover:bg-purple-700 text-white font-semibold py-2 px-4 rounded">
            Capture Photo
          </button>
        </div>
      </div>
      <div class="flex justify-end px-6 py-4">
        <button onclick="closeUploadModal()" class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-semibold py-2 px-4 rounded">Close</button>
      </div>
    </div>
  </div>

  <!-- Reset Data Confirmation Modal -->
  <div id="resetModal" class="fixed inset-0 flex items-center justify-center bg-gray-800 bg-opacity-50 hidden">
    <div class="bg-white rounded-lg shadow-lg w-11/12 sm:w-1/3">
      <div class="px-6 py-4">
        <h3 class="text-lg sm:text-xl font-semibold text-gray-800">Confirm Reset</h3>
        <p class="mt-2 text-gray-600">Are you sure you want to reset all data? This action cannot be undone.</p>
      </div>
      <div class="flex justify-end px-6 py-4">
        <button onclick="closeResetModal()" class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-semibold py-2 px-4 rounded mr-2">Cancel</button>
        <button onclick="confirmResetData()" class="bg-red-500 hover:bg-red-700 text-white font-semibold py-2 px-4 rounded">Reset</button>
      </div>
    </div>
  </div>

  <!-- Delete Patient Confirmation Modal -->
  <div id="deletePatientModal" class="fixed inset-0 flex items-center justify-center bg-gray-800 bg-opacity-50 hidden">
    <div class="bg-white rounded-lg shadow-lg w-11/12 sm:w-1/3">
      <div class="px-6 py-4">
        <h3 class="text-lg sm:text-xl font-semibold text-gray-800">Confirm Deletion</h3>
        <p class="mt-2 text-gray-600">Are you sure you want to delete all data for the selected patient? This action cannot be undone.</p>
      </div>
      <div class="flex justify-end px-6 py-4">
        <button onclick="closeDeletePatientModal()" class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-semibold py-2 px-4 rounded mr-2">Cancel</button>
        <button onclick="confirmDeletePatientData()" class="bg-red-500 hover:bg-red-700 text-white font-semibold py-2 px-4 rounded">Delete</button>
      </div>
    </div>
  </div>

  <script>
    let dataStore = JSON.parse(localStorage.getItem('kneeFlexionData')) || [];
    let chart;
    let patientSelect = document.getElementById('patientSelect');

    // Modal Elements
    const uploadModal = document.getElementById('uploadModal');
    const resetModal = document.getElementById('resetModal');
    const deletePatientModal = document.getElementById('deletePatientModal');
    const infoModal = document.getElementById('infoModal'); // New Info Modal
    const videoStream = document.getElementById('videoStream');
    const cameraSection = document.getElementById('cameraSection');
    let mediaStream = null;
    let currentCameraFacingMode = 'environment'; // Default to back camera

    /**
     * Toggle between front and back cameras
     */
    function flipCamera() {
      if (currentCameraFacingMode === 'environment') {
        currentCameraFacingMode = 'user';
      } else {
        currentCameraFacingMode = 'environment';
      }
      switchCamera();
    }

    /**
     * Switch the camera stream to the current facing mode
     */
    async function switchCamera() {
      if (mediaStream) {
        // Stop existing tracks
        mediaStream.getTracks().forEach(track => track.stop());
      }

      try {
        mediaStream = await navigator.mediaDevices.getUserMedia({
          video: {
            facingMode: currentCameraFacingMode
          }
        });
        videoStream.srcObject = mediaStream;
        videoStream.play();
      } catch (error) {
        showWarning('Unable to switch camera. Please try again or use the upload option.');
        console.error(error);
      }
    }

    function setButtonState(buttonId, isProcessing) {
      const button = document.getElementById(buttonId);
      button.disabled = isProcessing;
      if (isProcessing) {
        button.innerHTML = 'Processing...';
      } else {
        if (buttonId === 'calculateButton') {
          button.innerHTML = 'Upload and Adjust Points <i class="fas fa-upload ml-2"></i>';
        } else {
          // Handle other buttons if needed
        }
      }
    }

    /**
     * Process image from either camera capture or file upload
     * @param {string} imageSrc - Data URL of the image
     */
    async function processImage(imageSrc) {
      const userName = document.getElementById('userName').value.trim();
      const date = document.getElementById('dateInput').value;
      const statusMessage = document.getElementById('statusMessage');

      if (!userName || !date || !imageSrc) {
        showWarning('Please provide all inputs.');
        return;
      }

      setButtonState('calculateButton', true);
      statusMessage.classList.remove('hidden');
      statusMessage.textContent = 'Loading image...';

      const img = new Image();
      img.src = imageSrc;
      img.onload = async () => {
        try {
          statusMessage.textContent = 'Estimating the pose...';
          const detector = await poseDetection.createDetector(poseDetection.SupportedModels.PoseNet);
          const poses = await detector.estimatePoses(img, { flipHorizontal: false });

          if (poses.length === 0 || !poses[0].keypoints) {
            showWarning('Unable to detect human pose. Please upload a valid image.');
            setButtonState('calculateButton', false);
            return;
          }

          let keypoints = poses[0].keypoints;

          // Validate that keypoints correspond to a side view
          const leftShoulder = keypoints.find(k => k.name === 'left_shoulder');
          const rightShoulder = keypoints.find(k => k.name === 'right_shoulder');
          const leftHip = keypoints.find(k => k.name === 'left_hip');
          const rightHip = keypoints.find(k => k.name === 'right_hip');

          if (!leftShoulder || !rightShoulder || !leftHip || !rightHip) {
            showWarning('Insufficient keypoints detected. Please ensure the patient is fully visible.');
            setButtonState('calculateButton', false);
            return;
          }

          // Check alignment for side view (e.g., shoulders and hips should be horizontally aligned)
          const shoulderDiff = Math.abs(leftShoulder.y - rightShoulder.y);
          const hipDiff = Math.abs(leftHip.y - rightHip.y);

          if (shoulderDiff > 30 || hipDiff > 30) { // Threshold in pixels, adjust as needed
            showWarning('Please capture the image from the side for accurate knee flexion measurement.');
            setButtonState('calculateButton', false);
            return;
          }

          let keypointsOfInterest = {
            hip: keypoints.find(k => k.name === 'left_hip'),
            knee: keypoints.find(k => k.name === 'left_knee'),
            ankle: keypoints.find(k => k.name === 'left_ankle')
          };

          // Validate that keypoints are detected
          if (!keypointsOfInterest.hip || !keypointsOfInterest.knee || !keypointsOfInterest.ankle) {
            showWarning('Unable to detect required keypoints. Please ensure the patient is positioned correctly.');
            setButtonState('calculateButton', false);
            return;
          }

          statusMessage.textContent = 'Drawing the keypoints on the image...';
          drawInteractiveAngleVisualization(img, keypointsOfInterest);
          setButtonState('calculateButton', false);
        } catch (error) {
          console.error(error);
          showWarning('An error occurred during image processing. Please try again.');
          setButtonState('calculateButton', false);
        }
      };
      img.onerror = () => {
        showWarning('Failed to load the image. Please try a different file.');
        setButtonState('calculateButton', false);
      };
    }

    function resetCalculateButton() {
      setButtonState('calculateButton', false);
      document.getElementById('statusMessage').classList.add('hidden');
    }

    function showWarning(message) {
      const warningBox = document.createElement('div');
      warningBox.className = 'bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded relative mb-4';
      warningBox.innerHTML = `<strong class='font-bold'>Warning: </strong><span class='block sm:inline'>${message}</span>`;
      document.querySelector('.container').insertBefore(warningBox, document.querySelector('.bg-white'));
      setTimeout(() => warningBox.remove(), 5000);
    }

    /**
     * Draws the interactive angle visualization on the canvas
     * @param {HTMLImageElement} img 
     * @param {Object} keypoints - Object containing 'hip', 'knee', 'ankle' keypoints
     */
    function drawInteractiveAngleVisualization(img, keypoints) {
      const container = document.getElementById('imageContainer');
      container.classList.remove('hidden');

      const canvas = document.getElementById('angleCanvas');
      const ctx = canvas.getContext('2d');

      // Adjust canvas size based on container's width
      const containerWidth = container.clientWidth;
      canvas.width = containerWidth * 0.95; // 95% of container
      canvas.height = (img.height / img.width) * canvas.width;

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

      const scaleX = canvas.width / img.width;
      const scaleY = canvas.height / img.height;

      // Directly access keypoints without using find
      let hip = scaleKeypoint(keypoints.hip, scaleX, scaleY);
      let knee = scaleKeypoint(keypoints.knee, scaleX, scaleY);
      let ankle = scaleKeypoint(keypoints.ankle, scaleX, scaleY);

      // Check if any keypoints are undefined
      if (!hip || !knee || !ankle) {
        showWarning('One or more keypoints are undefined. Please try uploading the image again.');
        return;
      }

      drawPointsAndLines(ctx, hip, knee, ankle);

      let selectedPoint = null;

      // Touch support for mobile devices
      const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;

      if (isTouchDevice) {
        canvas.addEventListener('touchstart', (e) => {
          e.preventDefault();
          const touch = e.touches[0];
          const mousePos = getTouchPos(canvas, touch);
          if (isPointClicked(mousePos, hip)) {
            selectedPoint = 'hip';
          } else if (isPointClicked(mousePos, knee)) {
            selectedPoint = 'knee';
          } else if (isPointClicked(mousePos, ankle)) {
            selectedPoint = 'ankle';
          }
        });

        canvas.addEventListener('touchmove', (e) => {
          if (selectedPoint) {
            e.preventDefault();
            const touch = e.touches[0];
            const mousePos = getTouchPos(canvas, touch);
            if (selectedPoint === 'hip') {
              hip = mousePos;
            } else if (selectedPoint === 'knee') {
              knee = mousePos;
            } else if (selectedPoint === 'ankle') {
              ankle = mousePos;
            }
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            drawPointsAndLines(ctx, hip, knee, ankle);
          }
        });

        canvas.addEventListener('touchend', () => {
          selectedPoint = null;
        });
      } else {
        // Mouse events for desktop
        canvas.addEventListener('mousedown', (e) => {
          const mousePos = getMousePos(canvas, e);
          if (isPointClicked(mousePos, hip)) {
            selectedPoint = 'hip';
          } else if (isPointClicked(mousePos, knee)) {
            selectedPoint = 'knee';
          } else if (isPointClicked(mousePos, ankle)) {
            selectedPoint = 'ankle';
          }
        });

        canvas.addEventListener('mousemove', (e) => {
          if (selectedPoint) {
            const mousePos = getMousePos(canvas, e);
            if (selectedPoint === 'hip') {
              hip = mousePos;
            } else if (selectedPoint === 'knee') {
              knee = mousePos;
            } else if (selectedPoint === 'ankle') {
              ankle = mousePos;
            }
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            drawPointsAndLines(ctx, hip, knee, ankle);
          }
        });

        canvas.addEventListener('mouseup', () => {
          selectedPoint = null;
        });

        canvas.addEventListener('mouseleave', () => {
          selectedPoint = null;
        });
      }

      document.getElementById('confirmButton').onclick = () => {
        const flexionAngle = calculateFlexionAngle(hip, knee, ankle);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
        drawPointsAndLines(ctx, hip, knee, ankle);
        const messageContainer = document.getElementById('angleMessageContainer');
        messageContainer.innerHTML = '';
        const messageBox = document.createElement('div');
        messageBox.className = 'bg-blue-100 border border-blue-400 text-blue-700 px-4 py-3 rounded relative mt-4';
        messageBox.innerHTML = `<strong class='font-bold'>Knee Flexion Angle: </strong><span class='block sm:inline'>${flexionAngle.toFixed(2)}째</span>`;
        messageContainer.appendChild(messageBox);
        const userName = document.getElementById('userName').value.trim();
        const date = document.getElementById('dateInput').value;

        // Remove existing entry for the same userName and date
        dataStore = dataStore.filter(entry => !(entry.userName === userName && entry.date === date));

        // Add the new entry
        dataStore.push({ userName, date, flexionAngle });

        // Sort the dataStore by date
        dataStore = dataStore.sort((a, b) => new Date(a.date) - new Date(b.date));

        // Save to localStorage
        localStorage.setItem('kneeFlexionData', JSON.stringify(dataStore));

        // Update patient select and select the current user
        updatePatientSelect(userName);

        // Draw the updated progress chart
        drawProgressChart();
      };
    }

    /**
     * Scales a keypoint based on the canvas scaling factors
     * @param {Object} keypoint - The keypoint object from PoseNet
     * @param {number} scaleX - Scaling factor for the X-axis
     * @param {number} scaleY - Scaling factor for the Y-axis
     * @returns {Object|null} - Scaled keypoint or null if undefined
     */
    function scaleKeypoint(keypoint, scaleX, scaleY) {
      if (!keypoint) return null;
      return {
        x: keypoint.x * scaleX,
        y: keypoint.y * scaleY
      };
    }

    /**
     * Draws points and lines on the canvas
     * @param {CanvasRenderingContext2D} ctx 
     * @param {Object} hip 
     * @param {Object} knee 
     * @param {Object} ankle 
     */
    function drawPointsAndLines(ctx, hip, knee, ankle) {
      // Draw points
      ctx.fillStyle = 'red';
      [hip, knee, ankle].forEach(point => {
        ctx.beginPath();
        ctx.arc(point.x, point.y, 10, 0, 2 * Math.PI);
        ctx.fill();
      });

      // Draw lines (thigh and shin)
      ctx.strokeStyle = '#4a90e2';
      ctx.lineWidth = 5;
      ctx.beginPath();
      ctx.moveTo(hip.x, hip.y);
      ctx.lineTo(knee.x, knee.y);
      ctx.lineTo(ankle.x, ankle.y);
      ctx.stroke();

      // Draw extended thigh line as a reference for 0째 flexion
      const thighVector = {
        x: knee.x - hip.x,
        y: knee.y - hip.y
      };
      const extensionLength = 100; // Length of the extended line

      const extendedThigh = {
        x: knee.x + (thighVector.x / Math.hypot(thighVector.x, thighVector.y)) * extensionLength,
        y: knee.y + (thighVector.y / Math.hypot(thighVector.x, thighVector.y)) * extensionLength
      };

      ctx.setLineDash([5, 5]); // Create a dashed line pattern
      ctx.beginPath();
      ctx.moveTo(knee.x, knee.y);
      ctx.lineTo(extendedThigh.x, extendedThigh.y);
      ctx.stroke();
      ctx.setLineDash([]); // Reset dash to solid lines for other elements

      // Draw the knee flexion angle arc based on the extended thigh reference and shin
      const flexionAngle = calculateFlexionAngle(hip, knee, ankle);
      drawAngleArc(ctx, knee, extendedThigh, ankle, flexionAngle);

      // Display the calculated angle on the canvas
      ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
      ctx.fillRect(knee.x + 15, knee.y - 45, 180, 50); // Increased width for definition text
      ctx.fillStyle = '#fff';
      ctx.font = '16px Arial';
      ctx.fillText(`${flexionAngle.toFixed(2)}째`, knee.x + 20, knee.y - 25);
      ctx.font = '12px Arial';
      ctx.fillText('(Knee Flexion Angle)', knee.x + 20, knee.y - 5);
    }

    /**
     * Draws an arc representing the flexion angle at the knee
     * @param {CanvasRenderingContext2D} ctx 
     * @param {Object} knee 
     * @param {Object} extendedThigh 
     * @param {Object} ankle 
     * @param {number} angle 
     */
    function drawAngleArc(ctx, knee, extendedThigh, ankle, angle) {
      const radius = 30;

      // Start angle is from the extended thigh to the knee
      const startAngle = Math.atan2(extendedThigh.y - knee.y, extendedThigh.x - knee.x);
      const endAngle = Math.atan2(ankle.y - knee.y, ankle.x - knee.x);

      ctx.beginPath();
      ctx.strokeStyle = '#ff0000';
      ctx.lineWidth = 3;

      // Draw the arc for knee flexion from extended thigh to shin
      ctx.arc(knee.x, knee.y, radius, startAngle, endAngle, false); // Changed anticlockwise to false
      ctx.stroke();
    }

    /**
     * Gets the mouse position relative to the canvas
     * @param {HTMLCanvasElement} canvas 
     * @param {MouseEvent} evt 
     * @returns {Object} - {x, y} coordinates
     */
    function getMousePos(canvas, evt) {
      const rect = canvas.getBoundingClientRect();
      return {
        x: (evt.clientX - rect.left) * (canvas.width / rect.width),
        y: (evt.clientY - rect.top) * (canvas.height / rect.height)
      };
    }

    /**
     * Gets the touch position relative to the canvas
     * @param {HTMLCanvasElement} canvas 
     * @param {Touch} touch 
     * @returns {Object} - {x, y} coordinates
     */
    function getTouchPos(canvas, touch) {
      const rect = canvas.getBoundingClientRect();
      return {
        x: (touch.clientX - rect.left) * (canvas.width / rect.width),
        y: (touch.clientY - rect.top) * (canvas.height / rect.height)
      };
    }

    /**
     * Determines if a point was clicked based on proximity
     * @param {Object} mousePos - {x, y} coordinates of the click
     * @param {Object} point - {x, y} coordinates of the keypoint
     * @returns {boolean}
     */
    function isPointClicked(mousePos, point) {
      if (!point) return false;
      const distance = Math.sqrt((mousePos.x - point.x) ** 2 + (mousePos.y - point.y) ** 2);
      return distance < 15;
    }

    /**
     * Calculates the knee flexion angle based on keypoints
     * @param {Object} hip 
     * @param {Object} knee 
     * @param {Object} ankle 
     * @returns {number} - Flexion angle in degrees
     */
    function calculateFlexionAngle(hip, knee, ankle) {
      if (!hip || !knee || !ankle) return 0;

      // Vector for the thigh (hip to knee)
      const thighVector = {
        x: knee.x - hip.x,
        y: knee.y - hip.y
      };

      // Extend the thigh line to use as a baseline for measurement
      const extensionLength = 100; // Arbitrary length to extend for visual reference

      const extendedThigh = {
        x: knee.x + (thighVector.x / Math.hypot(thighVector.x, thighVector.y)) * extensionLength,
        y: knee.y + (thighVector.y / Math.hypot(thighVector.x, thighVector.y)) * extensionLength
      };

      // Vector for the shin (knee to ankle)
      const shinVector = {
        x: ankle.x - knee.x,
        y: ankle.y - knee.y
      };

      // Calculate angle using dot product formula
      const dotProduct = thighVector.x * shinVector.x + thighVector.y * shinVector.y;
      const magnitude1 = Math.hypot(thighVector.x, thighVector.y);
      const magnitude2 = Math.hypot(shinVector.x, shinVector.y);

      const cosTheta = dotProduct / (magnitude1 * magnitude2);
      let angleRad = Math.acos(Math.max(-1, Math.min(1, cosTheta)));
      let angleDeg = angleRad * (180 / Math.PI);

      // No need to adjust the angle based on the direction anymore
      // The measurement direction has been reversed in the arc drawing

      return angleDeg;
    }

    // Modal Control Functions

    function openUploadModal() {
      uploadModal.classList.remove('hidden');
      uploadModal.classList.add('flex');
    }

    function closeUploadModal() {
      uploadModal.classList.add('hidden');
      uploadModal.classList.remove('flex');
      closeCamera(); // Ensure camera is closed if it was open
    }

    // Trigger the hidden file input
    function triggerImageUpload() {
      document.getElementById('imageInput').click();
    }

    // Handle image upload via file input
    document.getElementById('imageInput').addEventListener('change', (event) => {
      const file = event.target.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = function(e) {
          closeUploadModal();
          processImage(e.target.result);
        };
        reader.readAsDataURL(file);
      }
    });

    /**
     * Open camera with the current facing mode
     */
    async function openCamera() {
      const cameraSection = document.getElementById('cameraSection');
      const video = document.getElementById('videoStream');

      try {
        mediaStream = await navigator.mediaDevices.getUserMedia({
          video: {
            facingMode: currentCameraFacingMode
          }
        });
        video.srcObject = mediaStream;
        video.play();
        video.style.display = 'block';
        cameraSection.classList.remove('hidden');
      } catch (error) {
        showWarning('Unable to access the camera. Please allow camera permissions or use the upload option.');
        console.error(error);
      }
    }

    /**
     * Capture photo from video stream
     */
    function capturePhoto() {
      const video = document.getElementById('videoStream');
      const canvas = document.createElement('canvas');
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
      const imageDataURL = canvas.toDataURL('image/png');

      // Stop the camera stream
      closeCamera();

      // Proceed with image processing
      closeUploadModal();
      processImage(imageDataURL);
    }

    /**
     * Close camera stream
     */
    function closeCamera() {
      const video = document.getElementById('videoStream');
      const cameraSection = document.getElementById('cameraSection');
      if (mediaStream) {
        mediaStream.getTracks().forEach(track => track.stop());
        mediaStream = null;
      }
      video.srcObject = null;
      video.style.display = 'none';
      cameraSection.classList.add('hidden');
    }

    // Reset Data Modal Functions

    function openResetModal() {
      resetModal.classList.remove('hidden');
      resetModal.classList.add('flex');
    }

    function closeResetModal() {
      resetModal.classList.add('hidden');
      resetModal.classList.remove('flex');
    }

    function confirmResetData() {
      // Clear all data
      dataStore = [];
      localStorage.removeItem('kneeFlexionData');
      updatePatientSelect();
      drawProgressChart();

      // Hide image container and reset form
      document.getElementById('imageContainer').classList.add('hidden');
      document.getElementById('userName').value = '';
      document.getElementById('dateInput').value = '';
      document.getElementById('imageInput').value = '';
      document.getElementById('angleMessageContainer').innerHTML = '';

      // Close the modal
      closeResetModal();
    }

    // Delete Patient Modal Functions

    function openDeletePatientModal() {
      // Only open if a patient is selected
      if (patientSelect.value) {
        deletePatientModal.classList.remove('hidden');
        deletePatientModal.classList.add('flex');
      } else {
        showWarning('No patient selected to delete.');
      }
    }

    function closeDeletePatientModal() {
      deletePatientModal.classList.add('hidden');
      deletePatientModal.classList.remove('flex');
    }

    function confirmDeletePatientData() {
      const selectedPatient = patientSelect.value;
      if (selectedPatient) {
        // Remove all entries for the selected patient
        dataStore = dataStore.filter(entry => entry.userName !== selectedPatient);
        localStorage.setItem('kneeFlexionData', JSON.stringify(dataStore));
        updatePatientSelect();
        drawProgressChart();

        // Hide image container and reset form if the deleted patient was currently displayed
        const currentUserName = document.getElementById('userName').value.trim();
        if (currentUserName === selectedPatient) {
          document.getElementById('imageContainer').classList.add('hidden');
          document.getElementById('userName').value = '';
          document.getElementById('dateInput').value = '';
          document.getElementById('imageInput').value = '';
          document.getElementById('angleMessageContainer').innerHTML = '';
        }

        // Close the modal
        closeDeletePatientModal();
      } else {
        showWarning('No patient selected to delete.');
      }
    }

    /**
     * Updates the patientSelect dropdown.
     * @param {string} [selectedUser] - Optional. The userName to be selected after updating the dropdown.
     */
    function updatePatientSelect(selectedUser) {
      const uniquePatients = [...new Set(dataStore.map(entry => entry.userName))];
      patientSelect.innerHTML = '';
      uniquePatients.forEach(patient => {
        const option = document.createElement('option');
        option.value = patient;
        option.textContent = patient;
        patientSelect.appendChild(option);
      });

      if (uniquePatients.length > 0) {
        if (selectedUser && uniquePatients.includes(selectedUser)) {
          patientSelect.value = selectedUser;
        } else {
          patientSelect.value = uniquePatients[0];
        }
        drawProgressChart();
      } else {
        if (chart) {
          chart.destroy();
          chart = null;
        }
      }
    }

    function updateProgressChart() {
      drawProgressChart();
    }

    /**
     * Draws the progress chart using Chart.js
     */
    function drawProgressChart() {
      const selectedPatient = patientSelect.value;
      const filteredDataStore = dataStore.filter(entry => entry.userName === selectedPatient);
      const sortedDataStore = filteredDataStore.sort((a, b) => new Date(a.date) - new Date(b.date));
      const labels = sortedDataStore.map(entry => entry.date);
      const data = sortedDataStore.map(entry => entry.flexionAngle);

      if (chart) {
        chart.destroy();
      }

      const ctx = document.getElementById('progressChart').getContext('2d');
      chart = new Chart(ctx, {
        type: 'line',
        data: {
          labels,
          datasets: [{
            label: 'Knee Flexion Over Time',
            data,
            borderColor: '#4a90e2',
            backgroundColor: 'rgba(74, 144, 226, 0.2)',
            fill: true,
            tension: 0.1, // Smooth curves
            pointRadius: 3, // Smaller points for mobile
            pointBackgroundColor: '#4a90e2',
            pointHoverRadius: 5,
            pointHoverBackgroundColor: '#fff',
            pointHoverBorderColor: '#4a90e2',
            pointHoverBorderWidth: 2,
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false, // Allows the chart to adjust height
          plugins: {
            legend: {
              display: true,
              labels: {
                font: {
                  size: 14
                }
              }
            },
            tooltip: {
              enabled: true,
              callbacks: {
                label: function(context) {
                  return `${context.parsed.y}째`;
                }
              }
            }
          },
          scales: {
            x: {
              title: {
                display: true,
                text: 'Date',
                font: {
                  size: 14
                }
              },
              ticks: {
                font: {
                  size: 12
                },
                autoSkip: true,
                maxTicksLimit: 10
              }
            },
            y: {
              title: {
                display: true,
                text: 'Flexion Angle (degrees)',
                font: {
                  size: 14
                }
              },
              ticks: {
                font: {
                  size: 12
                },
                beginAtZero: true,
                suggestedMax: 150 // To accommodate typical knee flexion range
              }
            }
          }
        }
      });
    }

    // Initialize patient select and chart on page load
    document.addEventListener('DOMContentLoaded', () => {
      if (dataStore.length > 0) {
        updatePatientSelect();
        drawProgressChart();
      }
    });

    // Information Modal Control Functions

    /**
     * Opens the Information Modal
     */
    function openInfoModal() {
      infoModal.classList.remove('hidden');
      infoModal.classList.add('flex');
    }

    /**
     * Closes the Information Modal
     */
    function closeInfoModal() {
      infoModal.classList.add('hidden');
      infoModal.classList.remove('flex');
    }
  </script>
</body>
</html>
